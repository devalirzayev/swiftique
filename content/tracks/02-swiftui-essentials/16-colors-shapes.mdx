---
title: "Colors & Shapes"
description: "Color, Gradient, Shape protocol, Path, and custom shapes"
sectionId: "2.6-styling"
sectionTitle: "Styling & Theming"
order: 16
tags: []
videoResources: []
prerequisites: []
---

# Colors & Shapes in SwiftUI

Colors and shapes are the visual building blocks of any SwiftUI application. Whether you're creating simple buttons or complex custom graphics, understanding how to work with colors, gradients, and shapes is essential for building polished iOS interfaces.

SwiftUI provides a declarative approach to drawing that's both powerful and intuitive. You'll describe *what* you want to draw rather than *how* to draw it, letting the framework handle the rendering details.

## Why Colors and Shapes Matter

In traditional UIKit, creating custom shapes required subclassing views and implementing drawing code with CoreGraphics. SwiftUI simplifies this dramatically with built-in shape types and a composable API. You can:

- Create reusable custom shapes that adapt to any size
- Apply sophisticated color effects with gradients
- Build complex graphics by combining simple shapes
- Animate shape transformations smoothly

Let's explore each component step by step.

## Working with Colors

### Basic Colors

SwiftUI's `Color` type works both as a view and as a modifier. You can use predefined semantic colors that automatically adapt to light and dark mode:

```swift
import SwiftUI

struct ColorExamplesView: View {
    var body: some View {
        VStack(spacing: 20) {
            // Predefined colors
            Color.blue
                .frame(width: 100, height: 100)
            
            // Semantic colors (adapt to light/dark mode)
            Color.primary
                .frame(width: 100, height: 100)
            
            // Using color as a modifier
            Text("Hello")
                .foregroundColor(.red)
        }
    }
}
```

### Custom Colors

You can create custom colors using RGB, HSB, or hex values:

```swift
struct CustomColorsView: View {
    var body: some View {
        VStack(spacing: 20) {
            // RGB with values 0-1
            Color(red: 0.2, green: 0.5, blue: 0.8)
                .frame(width: 100, height: 100)
            
            // With opacity
            Color(red: 1.0, green: 0.0, blue: 0.0, opacity: 0.5)
                .frame(width: 100, height: 100)
            
            // HSB (Hue, Saturation, Brightness)
            Color(hue: 0.6, saturation: 0.8, brightness: 0.9)
                .frame(width: 100, height: 100)
        }
    }
}
```

### Color Assets

For production apps, define colors in an asset catalog to support light/dark mode variants and reusability:

```swift
// Reference a color from Assets.xcassets
Color("BrandPrimary")

// With fallback
Color("BrandPrimary", bundle: .main)
```

**Common Mistake:** Using hardcoded RGB values that don't adapt to dark mode. Always consider using semantic colors or asset catalog colors with variants.

## Gradients

SwiftUI provides three gradient types: linear, radial, and angular.

### Linear Gradients

Linear gradients transition colors along a straight line:

```swift
struct LinearGradientExamples: View {
    var body: some View {
        VStack(spacing: 20) {
            // Simple two-color gradient
            LinearGradient(
                colors: [.blue, .purple],
                startPoint: .top,
                endPoint: .bottom
            )
            .frame(height: 100)
            
            // Multi-stop gradient
            LinearGradient(
                colors: [.red, .orange, .yellow],
                startPoint: .leading,
                endPoint: .trailing
            )
            .frame(height: 100)
            
            // Using Gradient with stops for precise control
            LinearGradient(
                gradient: Gradient(stops: [
                    .init(color: .blue, location: 0.0),
                    .init(color: .purple, location: 0.3),
                    .init(color: .pink, location: 1.0)
                ]),
                startPoint: .topLeading,
                endPoint: .bottomTrailing
            )
            .frame(height: 100)
        }
    }
}
```

### Radial Gradients

Radial gradients radiate from a center point:

```swift
struct RadialGradientExamples: View {
    var body: some View {
        VStack(spacing: 20) {
            RadialGradient(
                colors: [.yellow, .orange, .red],
                center: .center,
                startRadius: 20,
                endRadius: 100
            )
            .frame(width: 200, height: 200)
            
            // Off-center gradient
            RadialGradient(
                colors: [.white, .blue],
                center: UnitPoint(x: 0.3, y: 0.3),
                startRadius: 10,
                endRadius: 150
            )
            .frame(width: 200, height: 200)
        }
    }
}
```

### Angular Gradients

Angular gradients (also called conic gradients) sweep around a center point:

```swift
struct AngularGradientExamples: View {
    var body: some View {
        VStack(spacing: 20) {
            // Rainbow wheel
            AngularGradient(
                colors: [.red, .orange, .yellow, .green, .blue, .purple, .red],
                center: .center
            )
            .frame(width: 200, height: 200)
            
            // With start angle
            AngularGradient(
                colors: [.blue, .purple],
                center: .center,
                angle: .degrees(0)
            )
            .frame(width: 200, height: 200)
        }
    }
}
```

**Edge Case:** Gradients with a single color will render as a solid color. Always provide at least two colors for a gradient effect.

## Built-in Shapes

SwiftUI includes several built-in shapes that conform to the `Shape` protocol.

### Basic Shapes

```swift
struct BasicShapesView: View {
    var body: some View {
        HStack(spacing: 20) {
            Rectangle()
                .fill(.blue)
                .frame(width: 100, height: 100)
            
            Circle()
                .fill(.red)
                .frame(width: 100, height: 100)
            
            Ellipse()
                .fill(.green)
                .frame(width: 120, height: 80)
            
            Capsule()
                .fill(.orange)
                .frame(width: 100, height: 50)
            
            RoundedRectangle(cornerRadius: 20)
                .fill(.purple)
                .frame(width: 100, height: 100)
        }
    }
}
```

### Shape Styles

Shapes can be filled, stroked, or both:

```swift
struct ShapeStylesView: View {
    var body: some View {
        VStack(spacing: 20) {
            // Fill
            Circle()
                .fill(.blue)
                .frame(width: 100, height: 100)
            
            // Stroke
            Circle()
                .stroke(.red, lineWidth: 5)
                .frame(width: 100, height: 100)
            
            // Stroke with style
            Circle()
                .stroke(.green, style: StrokeStyle(
                    lineWidth: 5,
                    lineCap: .round,
                    lineJoin: .round,
                    dash: [10, 5]
                ))
                .frame(width: 100, height: 100)
            
            // Fill with gradient
            Circle()
                .fill(
                    LinearGradient(
                        colors: [.purple, .pink],
                        startPoint: .top,
                        endPoint: .bottom
                    )
                )
                .frame(width: 100, height: 100)
            
            // Overlay for fill and stroke
            Circle()
                .fill(.yellow)
                .overlay(
                    Circle()
                        .stroke(.orange, lineWidth: 3)
                )
                .frame(width: 100, height: 100)
        }
    }
}
```

**Common Mistake:** Trying to apply both `.fill()` and `.stroke()` to the same shape. They overwrite each other. Use `.overlay()` or `.background()` to combine them.

## The Shape Protocol

The `Shape` protocol is what makes shapes in SwiftUI work. Any type conforming to `Shape` must implement a single requirement:

```swift
func path(in rect: CGRect) -> Path
```

This method receives the bounds rectangle and returns a `Path` describing the shape's outline.

### Creating Custom Shapes

Let's create a simple triangle shape:

```swift
struct Triangle: Shape {
    func path(in rect: CGRect) -> Path {
        var path = Path()
        
        path.move(to: CGPoint(x: rect.midX, y: rect.minY))
        path.addLine(to: CGPoint(x: rect.minX, y: rect.maxY))
        path.addLine(to: CGPoint(x: rect.maxX, y: rect.maxY))
        path.closeSubpath()
        
        return path
    }
}

struct TriangleView: View {
    var body: some View {
        Triangle()
            .fill(.blue)
            .frame(width: 100, height: 100)
    }
}
```

### Parametric Custom Shapes

Shapes can have properties that modify their appearance:

```swift
struct Star: Shape {
    var points: Int
    var innerRadiusRatio: Double
    
    func path(in rect: CGRect) -> Path {
        var path = Path()
        
        let center = CGPoint(x: rect.midX, y: rect.midY)
        let outerRadius = min(rect.width, rect.height) / 2
        let innerRadius = outerRadius * innerRadiusRatio
        let angleIncrement = .pi * 2 / Double(points * 2)
        
        var angle: Double = -.pi / 2
        
        for i in 0..<points * 2 {
            let radius = i.isMultiple(of: 2) ? outerRadius : innerRadius
            let x = center.x + cos(angle) * radius
            let y = center.y + sin(angle) * radius
            
            if i == 0 {
                path.move(to: CGPoint(x: x, y: y))
            } else {
                path.addLine(to: CGPoint(x: x, y: y))
            }
            
            angle += angleIncrement
        }
        
        path.closeSubpath()
        return path
    }
}

struct StarView: View {
    var body: some View {
        Star(points: 5, innerRadiusRatio: 0.4)
            .fill(.yellow)
            .frame(width: 100, height: 100)
    }
}
```

### Animatable Shapes

Make shape properties animatable by conforming to `Animatable`:

```swift
struct AnimatableStar: Shape {
    var points: Int
    var innerRadiusRatio: Double
    
    var animatableData: Double {
        get { innerRadiusRatio }
        set { innerRadiusRatio = newValue }
    }
    
    func path(in rect: CGRect) -> Path {
        // Same implementation as Star above
        var path = Path()
        let center = CGPoint(x: rect.midX, y: rect.midY)
        let outerRadius = min(rect.width, rect.height) / 2
        let innerRadius = outerRadius * innerRadiusRatio
        let angleIncrement = .pi * 2 / Double(points * 2)
        var angle: Double = -.pi / 2
        
        for i in 0..<points * 2 {
            let radius = i.isMultiple(of: 2) ? outerRadius : innerRadius
            let x = center.x + cos(angle) * radius
            let y = center.y + sin(angle) * radius
            
            if i == 0 {
                path.move(to: CGPoint(x: x, y: y))
            } else {
                path.addLine(to: CGPoint(x: x, y: y))
            }
            angle += angleIncrement
        }
        
        path.closeSubpath()
        return path
    }
}

struct AnimatedStarView: View {
    @State private var innerRatio = 0.4
    
    var body: some View {
        AnimatableStar(points: 5, innerRadiusRatio: innerRatio)
            .fill(.yellow)
            .frame(width: 200, height: 200)
            .onTapGesture {
                withAnimation(.easeInOut(duration: 1.0)) {
                    innerRatio = innerRatio == 0.4 ? 0.8 : 0.4
                }
            }
    }
}
```

## Working with Paths

`Path` is the fundamental drawing primitive that shapes use. You can use it directly for complex drawings:

```swift
struct PathExamples: View {
    var body: some View {
        VStack(spacing: 30) {
            // Simple line path
            Path { path in
                path.move(to: CGPoint(x: 0, y: 0))
                path.addLine(to: CGPoint(x: 100, y: 100))
            }
            .stroke(.blue, lineWidth: 2)
            .frame(width: 100, height: 100)
            
            // Curved path
            Path { path in
                path.move(to: CGPoint(x: 0, y: 50))
                path.addQuadCurve(
                    to: CGPoint(x: 100, y: 50),
                    control: CGPoint(x: 50, y: 0)
                )
            }
            .stroke(.red, lineWidth: 2)
            .frame(width: 100, height: 100)
            
            // Bezier curve
            Path { path in
                path.move(to: CGPoint(x: 0, y: 50))
                path.addCurve(
                    to: CGPoint(x: 100, y: 50),
                    control1: CGPoint(x: 25, y: 0),
                    control2: CGPoint(x: 75, y: 100)
                )
            }
            .stroke(.green, lineWidth: 2)
            .frame(width: 100, height: 100)
        }
    }
}
```

### Path Drawing Methods

Key methods for building paths:

```swift
struct ComplexPath: View {
    var body: some View {
        Path { path in
            // Start point
            path.move(to: CGPoint(x: 50, y: 10))
            
            // Lines
            path.addLine(to: CGPoint(x: 90, y: 50))
            
            // Arcs
            path.addArc(
                center: CGPoint(x: 50, y: 50),
                radius: 40,
                startAngle: .degrees(0),
                endAngle: .degrees(90),
                clockwise: false
            )
            
            // Rectangles
            path.addRect(CGRect(x: 10, y: 60, width: 30, height: 30))
            
            // Rounded rectangles
            path.addRoundedRect(
                in: CGRect(x: 50, y: 60, width: 40, height: 30),
                cornerSize: CGSize(width: 10, height: 10)
            )
            
            // Ellipses
            path.addEllipse(in: CGRect(x: 10, y: 100, width: 50, height: 30))
            
            // Close the current subpath
            path.closeSubpath()
        }
        .stroke(.purple, lineWidth: 2)
        .frame(width: 100, height: 140)
    }
}
```

**Edge Case:** Forgetting to call `closeSubpath()` can lead to unexpected results when filling shapes, especially with self-intersecting paths.

## Advanced Shape Techniques

### Trimming Shapes

The `.trim()` modifier allows you to draw partial shapes, which is perfect for progress indicators and animated reveals:

```swift
struct ProgressRing: View {
    let progress: Double // 0.0 to 1.0

    var body: some View {
        ZStack {
            // Background track
            Circle()
                .stroke(Color.gray.opacity(0.3), lineWidth: 10)

            // Progress arc
            Circle()
                .trim(from: 0, to: progress)
                .stroke(
                    Color.blue,
                    style: StrokeStyle(
                        lineWidth: 10,
                        lineCap: .round
                    )
                )
                .rotationEffect(.degrees(-90))
                .animation(.easeInOut, value: progress)
        }
        .frame(width: 100, height: 100)
    }
}
```

The `from` and `to` parameters range from 0.0 (start) to 1.0 (full shape). You can animate these values for smooth drawing effects.

### Combining Shapes

You can layer and combine shapes to create complex visuals:

```swift
struct BadgeView: View {
    var body: some View {
        ZStack {
            Circle()
                .fill(Color.blue)
                .frame(width: 80, height: 80)

            Star(points: 5, innerRatio: 0.4)
                .fill(Color.yellow)
                .frame(width: 50, height: 50)
        }
    }
}
```

### Shape Modifiers Summary

- `.fill()` — Fill the interior with a color or gradient
- `.stroke()` — Draw the outline only
- `.strokeBorder()` — Stroke inside the shape boundary (available on `InsettableShape`)
- `.trim(from:to:)` — Draw a partial shape
- `.size()` — Set explicit dimensions
- `.offset()` — Move the shape
- `.rotation()` — Rotate the shape path

## Common Mistakes

**Using `.foregroundColor()` instead of `.fill()` for shapes.** While `.foregroundColor()` works, `.fill()` is more explicit and allows gradient fills.

**Forgetting `.stroke()` returns a `View`, not a `Shape`.** You can't chain shape operations after `.stroke()`. Apply shape modifiers like `.trim()` before `.stroke()`.

**Not using `strokeBorder` when you need inset strokes.** Regular `.stroke()` draws centered on the shape boundary, meaning half the stroke extends outside. Use `.strokeBorder()` to keep strokes fully inside.

## Summary Table

| Concept | Type/Modifier | Purpose | Example |
|---------|--------------|---------|---------|
| **Built-in Shapes** | `Rectangle`, `Circle`, `Ellipse`, `Capsule`, `RoundedRectangle` | Ready-to-use shape primitives | `Circle().fill(.blue)` |
| **Custom Shapes** | `Shape` protocol with `path(in:)` | Draw arbitrary shapes with paths | `struct Triangle: Shape { ... }` |
| **Color Literals** | `Color.red`, `Color(red:green:blue:)` | Solid colors | `Color(hue: 0.6, saturation: 0.8, brightness: 1.0)` |
| **Asset Colors** | `Color("CustomColor")` | Colors from asset catalog | Supports light/dark mode automatically |
| **Linear Gradient** | `LinearGradient` | Color transition along a line | `LinearGradient(colors: [.blue, .purple], startPoint: .top, endPoint: .bottom)` |
| **Radial Gradient** | `RadialGradient` | Color transition from center outward | `RadialGradient(colors: [.white, .black], center: .center, startRadius: 0, endRadius: 100)` |
| **Angular Gradient** | `AngularGradient` | Color transition around a center point | `AngularGradient(colors: [.red, .blue, .red], center: .center)` |
| **Fill** | `.fill()` | Fill shape interior | `RoundedRectangle(cornerRadius: 10).fill(.green)` |
| **Stroke** | `.stroke()` | Draw shape outline | `Circle().stroke(.red, lineWidth: 3)` |
| **Trim** | `.trim(from:to:)` | Draw partial shape | `Circle().trim(from: 0, to: 0.75)` |
| **Custom Path** | `Path` | Freeform drawing with lines and curves | `path.addLine(to:)`, `path.addCurve(to:...)` |

## Official Resources

- [Apple Documentation: Shape](https://developer.apple.com/documentation/swiftui/shape)
- [Apple Documentation: Path](https://developer.apple.com/documentation/swiftui/path)
- [Apple Documentation: Color](https://developer.apple.com/documentation/swiftui/color)
- [Apple Documentation: Gradient](https://developer.apple.com/documentation/swiftui/gradient)
- [WWDC21: Add Rich Graphics to Your SwiftUI App](https://developer.apple.com/videos/play/wwdc2021/10021/)