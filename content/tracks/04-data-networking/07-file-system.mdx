---
title: "File System & Documents"
description: "Reading and writing files, document directory, and FileManager"
sectionId: "4.3-persistence"
sectionTitle: "Data Persistence"
order: 7
tags: []
videoResources: []
prerequisites: []
---

# File System & Documents in iOS

Every iOS app runs in its own sandbox—a secure, isolated environment where it can store and access files. Understanding how to work with the file system is essential for persisting user data, caching resources, and managing documents. Unlike desktop applications where you might freely access any directory, iOS apps have strict constraints on where they can read and write files.

## Why File System Management Matters

The iOS file system allows you to:
- **Persist user data** between app launches
- **Cache downloaded content** to reduce network usage
- **Store documents** that users create or import
- **Share files** with other apps via the document picker
- **Comply with iCloud backup policies** by organizing files correctly

Apple's file system API centers around `FileManager`, a class that handles file operations like creating, moving, copying, and deleting files and directories.

## Understanding the iOS Sandbox

iOS apps can only access files within their sandbox. The most important directories are:

- **Documents**: Store user-generated content that should be backed up to iCloud
- **Library/Caches**: Store downloaded or cached files that can be regenerated
- **Library/Application Support**: Store app-specific files that aren't user-facing
- **tmp**: Store temporary files that the system may delete at any time

```swift
import Foundation

func printStandardDirectories() {
    let fileManager = FileManager.default
    
    // Documents directory - user files, backed up
    if let documentsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first {
        print("Documents: \(documentsURL.path)")
    }
    
    // Caches directory - temporary data, not backed up
    if let cachesURL = fileManager.urls(for: .cachesDirectory, in: .userDomainMask).first {
        print("Caches: \(cachesURL.path)")
    }
    
    // Application Support directory - app files, backed up
    if let appSupportURL = fileManager.urls(for: .applicationSupportDirectory, in: .userDomainMask).first {
        print("App Support: \(appSupportURL.path)")
    }
    
    // Temporary directory - cleared by system
    let tmpURL = fileManager.temporaryDirectory
    print("Temp: \(tmpURL.path)")
}
```

## Working with FileManager

`FileManager` is the primary interface for file operations. You typically use the shared singleton instance:

```swift
let fileManager = FileManager.default
```

### Checking if Files Exist

Before reading or deleting a file, check if it exists:

```swift
func fileExists(at url: URL) -> Bool {
    return FileManager.default.fileExists(atPath: url.path)
}

// More detailed check that distinguishes files from directories
func checkFileType(at url: URL) {
    let fileManager = FileManager.default
    var isDirectory: ObjCBool = false
    
    if fileManager.fileExists(atPath: url.path, isDirectory: &isDirectory) {
        if isDirectory.boolValue {
            print("Directory exists at path")
        } else {
            print("File exists at path")
        }
    } else {
        print("Nothing exists at path")
    }
}
```

### Creating Directories

Always create intermediate directories when needed:

```swift
func createDirectory(at url: URL) throws {
    let fileManager = FileManager.default
    
    // Check if directory already exists
    if !fileManager.fileExists(atPath: url.path) {
        try fileManager.createDirectory(
            at: url,
            withIntermediateDirectories: true, // Creates parent directories if needed
            attributes: nil
        )
        print("Directory created successfully")
    }
}

// Example usage
func setupAppDirectories() {
    guard let documentsURL = FileManager.default.urls(
        for: .documentDirectory,
        in: .userDomainMask
    ).first else {
        print("Could not access documents directory")
        return
    }
    
    let dataDirectory = documentsURL.appendingPathComponent("UserData")
    
    do {
        try createDirectory(at: dataDirectory)
    } catch {
        print("Failed to create directory: \(error.localizedDescription)")
    }
}
```

## Writing Files

### Writing Strings

```swift
func writeTextFile(content: String, to filename: String) throws {
    guard let documentsURL = FileManager.default.urls(
        for: .documentDirectory,
        in: .userDomainMask
    ).first else {
        throw FileSystemError.directoryNotFound
    }
    
    let fileURL = documentsURL.appendingPathComponent(filename)
    
    try content.write(to: fileURL, atomically: true, encoding: .utf8)
    print("File written to: \(fileURL.path)")
}

// Usage
do {
    try writeTextFile(content: "Hello, iOS!", to: "greeting.txt")
} catch {
    print("Error writing file: \(error)")
}
```

The `atomically` parameter is important: when `true`, the system writes to a temporary file first, then moves it to the final location. This prevents data corruption if the write fails midway.

### Writing Data

For binary data (like images), use `Data`:

```swift
func saveImage(_ image: UIImage, filename: String) throws {
    guard let documentsURL = FileManager.default.urls(
        for: .documentDirectory,
        in: .userDomainMask
    ).first else {
        throw FileSystemError.directoryNotFound
    }
    
    let fileURL = documentsURL.appendingPathComponent(filename)
    
    // Convert UIImage to PNG data
    guard let imageData = image.pngData() else {
        throw FileSystemError.imageConversionFailed
    }
    
    try imageData.write(to: fileURL, options: .atomic)
    print("Image saved to: \(fileURL.path)")
}
```

### Writing JSON

Encoding Swift objects to JSON is a common use case:

```swift
struct UserProfile: Codable {
    let username: String
    let email: String
    let age: Int
}

func saveUserProfile(_ profile: UserProfile, to filename: String) throws {
    guard let documentsURL = FileManager.default.urls(
        for: .documentDirectory,
        in: .userDomainMask
    ).first else {
        throw FileSystemError.directoryNotFound
    }
    
    let fileURL = documentsURL.appendingPathComponent(filename)
    
    let encoder = JSONEncoder()
    encoder.outputFormatting = .prettyPrinted // Makes JSON human-readable
    
    let jsonData = try encoder.encode(profile)
    try jsonData.write(to: fileURL, options: .atomic)
}

// Usage
let profile = UserProfile(username: "john_doe", email: "john@example.com", age: 30)
do {
    try saveUserProfile(profile, to: "profile.json")
} catch {
    print("Error saving profile: \(error)")
}
```

## Reading Files

### Reading Strings

```swift
func readTextFile(filename: String) throws -> String {
    guard let documentsURL = FileManager.default.urls(
        for: .documentDirectory,
        in: .userDomainMask
    ).first else {
        throw FileSystemError.directoryNotFound
    }
    
    let fileURL = documentsURL.appendingPathComponent(filename)
    
    // This throws if the file doesn't exist or can't be read
    let content = try String(contentsOf: fileURL, encoding: .utf8)
    return content
}

// Usage with error handling
do {
    let greeting = try readTextFile(filename: "greeting.txt")
    print("File content: \(greeting)")
} catch {
    print("Error reading file: \(error)")
}
```

### Reading Data

```swift
func loadImage(filename: String) throws -> UIImage {
    guard let documentsURL = FileManager.default.urls(
        for: .documentDirectory,
        in: .userDomainMask
    ).first else {
        throw FileSystemError.directoryNotFound
    }
    
    let fileURL = documentsURL.appendingPathComponent(filename)
    
    let imageData = try Data(contentsOf: fileURL)
    
    guard let image = UIImage(data: imageData) else {
        throw FileSystemError.imageConversionFailed
    }
    
    return image
}
```

### Reading JSON

```swift
func loadUserProfile(from filename: String) throws -> UserProfile {
    guard let documentsURL = FileManager.default.urls(
        for: .documentDirectory,
        in: .userDomainMask
    ).first else {
        throw FileSystemError.directoryNotFound
    }
    
    let fileURL = documentsURL.appendingPathComponent(filename)
    
    let jsonData = try Data(contentsOf: fileURL)
    
    let decoder = JSONDecoder()
    let profile = try decoder.decode(UserProfile.self, from: jsonData)
    
    return profile
}

// Usage
do {
    let profile = try loadUserProfile(from: "profile.json")
    print("Loaded profile: \(profile.username)")
} catch {
    print("Error loading profile: \(error)")
}
```

## Listing Directory Contents

```swift
func listFiles(in directory: FileManager.SearchPathDirectory) throws -> [URL] {
    let fileManager = FileManager.default
    
    guard let directoryURL = fileManager.urls(
        for: directory,
        in: .userDomainMask
    ).first else {
        throw FileSystemError.directoryNotFound
    }
    
    let fileURLs = try fileManager.contentsOfDirectory(
        at: directoryURL,
        includingPropertiesForKeys: nil,
        options: .skipsHiddenFiles
    )
    
    return fileURLs
}

// Usage
do {
    let files = try listFiles(in: .documentDirectory)
    print("Files in Documents:")
    for fileURL in files {
        print("  - \(fileURL.lastPathComponent)")
    }
} catch {
    print("Error listing files: \(error)")
}
```

### Getting File Attributes

```swift
func getFileInfo(at url: URL) throws {
    let fileManager = FileManager.default
    let attributes = try fileManager.attributesOfItem(atPath: url.path)
    
    if let fileSize = attributes[.size] as? Int {
        print("File size: \(fileSize) bytes")
    }
    
    if let modificationDate = attributes[.modificationDate] as? Date {
        print("Modified: \(modificationDate)")
    }
    
    if let creationDate = attributes[.creationDate] as? Date {
        print("Created: \(creationDate)")
    }
}

// Alternative approach using resource values
func getFileInfoModern(at url: URL) throws {
    let resourceValues = try url.resourceValues(forKeys: [
        .fileSizeKey,
        .contentModificationDateKey,
        .creationDateKey
    ])
    
    if let fileSize = resourceValues.fileSize {
        print("File size: \(fileSize) bytes")
    }
    
    if let modificationDate = resourceValues.contentModificationDate {
        print("Modified: \(modificationDate)")
    }
    
    if let creationDate = resourceValues.creationDate {
        print("Created: \(creationDate)")
    }
}
```

## Deleting Files and Directories

```swift
func deleteFile(at url: URL) throws {
    let fileManager = FileManager.default
    
    // Check if file exists before attempting to delete
    guard fileManager.fileExists(atPath: url.path) else {
        print("File doesn't exist, nothing to delete")
        return
    }
    
    try fileManager.removeItem(at: url)
    print("File deleted successfully")
}

// Delete all files in a directory
func clearDirectory(_ directory: FileManager.SearchPathDirectory) throws {
    let fileManager = FileManager.default
    
    guard let directoryURL = fileManager.urls(
        for: directory,
        in: .userDomainMask
    ).first else {
        throw FileSystemError.directoryNotFound
    }
    
    let fileURLs = try fileManager.contentsOfDirectory(
        at: directoryURL,
        includingPropertiesForKeys: nil
    )
    
    for fileURL in fileURLs {
        try fileManager.removeItem(at: fileURL)
    }
    
    print("Directory cleared: \(fileURLs.count) items deleted")
}
```

## Copying and Moving Files

```swift
func copyFile(from sourceURL: URL, to destinationURL: URL) throws {
    let fileManager = FileManager.default
    
    // Check if source exists
    guard fileManager.fileExists(atPath: sourceURL.path) else {
        throw FileSystemError.sourceFileNotFound
    }
    
    // If destination exists, remove it first (or handle differently)
    if fileManager.fileExists(atPath: destinationURL.path) {
        try fileManager.removeItem(at: destinationURL)
    }
    
    try fileManager.copyItem(at: sourceURL, to: destinationURL)
    print("File copied successfully")
}

func moveFile(from sourceURL: URL, to destinationURL: URL) throws {
    let fileManager = FileManager.default
    
    // Check if source exists
    guard fileManager.fileExists(atPath: sourceURL.path) else {
        throw FileSystemError.sourceFileNotFound
    }
    
    // If destination exists, remove it first
    if fileManager.fileExists(atPath: destinationURL.path) {
        try fileManager.removeItem(at: destinationURL)
    }
    
    try fileManager.moveItem(at: sourceURL, to: destinationURL)
    print("File moved successfully")
}
```

## Working with URLs

iOS uses `URL` (formerly `NSURL`) to represent file paths. Always use URL methods rather than string manipulation:

```swift
// ✅ Correct: Use URL methods
let documentsURL = FileManager.default.urls(
    for: .documentDirectory,
    in: .userDomainMask
).first!

let fileURL = documentsURL.appendingPathComponent("data.json")
let parentURL = fileURL.deletingLastPathComponent()
let filename = fileURL.lastPathComponent
let fileExtension = fileURL.pathExtension

// ❌ Incorrect: String manipulation is error-prone
let wrongPath = documentsURL.path + "/data.json" // Risky!
```

### Handling Filenames Safely

```swift
func sanitizeFilename(_ filename: String) -> String {
    // Remove or replace invalid characters
    let invalidCharacters = CharacterSet(charactersIn: ":/\\?%*|\"<>")
    return filename.components(separatedBy: invalidCharacters).joined(separator: "_")
}

func saveFileWithSanitizedName(content: String, filename: String) throws {
    guard let documentsURL = FileManager.default.urls(
        for: .documentDirectory,
        in: .userDomainMask
    ).first else {
        throw FileSystemError.directoryNotFound
    }
    
    let sanitizedName = sanitizeFilename(filename)
    let fileURL = documentsURL.appendingPathComponent(sanitizedName)
    
    try content.write(to: fileURL, atomically: true, encoding: .utf8)
}
```

## Common Mistakes and Edge Cases

### 1. Not Handling Missing Directories

Always check or create directories before writing:

```swift
// ❌ Bad: Assumes directory exists
func saveFileBad(data: Data, to filename: String) throws {
    let fileURL = getDocumentsDirectory()
        .appendingPathComponent("MyApp")
        .appendingPathComponent(filename)
    
    try data.write(to: fileURL) // May fail if MyApp directory doesn't exist
}

// ✅ Good: Ensures directory exists
func saveFileGood(data: Data, to filename: String) throws {
    let directory = getDocumentsDirectory().appendingPathComponent("MyApp")
    
    try FileManager.default.createDirectory(
        at: directory,
        withIntermediateDirectories: true,
        attributes: nil
    )
    
    let fileURL = directory.appendingPathComponent(filename)
    try data.write(to: fileURL)
}
```

### 2. Not Using Atomic Writes

```swift
// ❌ Bad: Non-atomic write can corrupt data if interrupted
try data.write(to: fileURL)

// ✅ Good: Atomic write uses a temporary file first
try data.write(to: fileURL, options: .atomic)
```

### 3. Storing Files in Wrong Directory

```swift
// ❌ Bad: Caches are for regeneratable data, not user documents
let cachesURL = FileManager.default.urls(for: .cachesDirectory, in: .userDomainMask).first!
let fileURL = cachesURL.appendingPathComponent("important_document.pdf")

// ✅ Good: User documents go in Documents directory
let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
let fileURL = documentsURL.appendingPathComponent("important_document.pdf")
```

### 4. Using String Paths Instead of URLs

```swift
// ❌ Bad: String manipulation is fragile
let path = "/Users/Documents/" + filename

// ✅ Good: URL methods handle path separators correctly
let url = documentsDirectory.appendingPathComponent(filename)
```

### 5. Not Handling iCloud Backup Exclusion

Large files that can be regenerated should be excluded from iCloud backup:

```swift
func excludeFromBackup(at url: URL) throws {
    var resourceValues = URLResourceValues()
    resourceValues.isExcludedFromBackup = true
    var mutableURL = url
    try mutableURL.setResourceValues(resourceValues)
}
```

## Summary Table

| Operation | API | Key Parameters | Notes |
|-----------|-----|---------------|-------|
| **Get directory** | `FileManager.urls(for:in:)` | `.documentDirectory`, `.cachesDirectory` | Returns array, use `.first` |
| **Check exists** | `FileManager.fileExists(atPath:)` | Path string | Returns `Bool` |
| **Create directory** | `FileManager.createDirectory(at:...)` | `withIntermediateDirectories: true` | Always use intermediate flag |
| **Write string** | `String.write(to:atomically:encoding:)` | `.utf8`, `atomically: true` | Atomic prevents corruption |
| **Write data** | `Data.write(to:options:)` | `.atomic` | Use for binary data |
| **Read string** | `String(contentsOf:encoding:)` | `.utf8` | Throws if file missing |
| **Read data** | `Data(contentsOf:)` | URL | Throws if file missing |
| **Delete** | `FileManager.removeItem(at:)` | URL | Check exists first |
| **Copy** | `FileManager.copyItem(at:to:)` | Source, destination URLs | Fails if destination exists |
| **Move** | `FileManager.moveItem(at:to:)` | Source, destination URLs | Fails if destination exists |
| **List contents** | `FileManager.contentsOfDirectory(at:...)` | `.skipsHiddenFiles` | Returns `[URL]` |
| **File attributes** | `URL.resourceValues(forKeys:)` | `.fileSizeKey`, `.creationDateKey` | Modern approach |

## Official Resources

- [Apple Documentation: FileManager](https://developer.apple.com/documentation/foundation/filemanager)
- [Apple Documentation: File System Basics](https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html)
- [Apple Documentation: URL](https://developer.apple.com/documentation/foundation/url)
- [Apple Documentation: Data](https://developer.apple.com/documentation/foundation/data)
- [WWDC19: What's New in File Management and Quick Look](https://developer.apple.com/videos/play/wwdc2019/719/)