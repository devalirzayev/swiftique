---
title: "Async Networking"
description: "Using async/await with URLSession, error handling, and timeouts"
sectionId: "4.1-networking"
sectionTitle: "Networking"
order: 2
tags: []
videoResources: []
prerequisites: []
---

# Async Networking in Swift

Networking is fundamental to modern iOS apps. Whether you're fetching user data, downloading images, or communicating with an API, you'll spend a significant amount of time working with network requests. Swift's async/await syntax, introduced in iOS 15, makes asynchronous networking code cleaner, more readable, and easier to reason about compared to completion handlers.

## Why Async/Await for Networking?

Before async/await, networking code relied on completion handlers (closures), which led to "callback hell" and made error handling cumbersome. Async/await allows you to write asynchronous code that reads like synchronous code, making it easier to understand control flow and handle errors.

Here's a quick comparison:

**Old completion handler approach:**

```swift
func fetchUser(completion: @escaping (Result<User, Error>) -> Void) {
    URLSession.shared.dataTask(with: url) { data, response, error in
        if let error = error {
            completion(.failure(error))
            return
        }
        // More nested logic...
    }.resume()
}
```

**Modern async/await approach:**

```swift
func fetchUser() async throws -> User {
    let (data, response) = try await URLSession.shared.data(from: url)
    // Linear, readable code
    return try JSONDecoder().decode(User.self, from: data)
}
```

## Basic Async Networking with URLSession

URLSession is Apple's built-in networking API. Starting with iOS 15, it includes async/await variants of its methods.

### Simple GET Request

```swift
struct Post: Codable {
    let id: Int
    let title: String
    let body: String
}

func fetchPost(id: Int) async throws -> Post {
    let url = URL(string: "https://jsonplaceholder.typicode.com/posts/\(id)")!
    
    let (data, response) = try await URLSession.shared.data(from: url)
    
    // Validate response
    guard let httpResponse = response as? HTTPURLResponse,
          (200...299).contains(httpResponse.statusCode) else {
        throw NetworkError.invalidResponse
    }
    
    let post = try JSONDecoder().decode(Post.self, from: data)
    return post
}
```

### Using the Function

To call an async function, you need to be in an async context:

```swift
// In a view controller or SwiftUI view
Task {
    do {
        let post = try await fetchPost(id: 1)
        print(post.title)
    } catch {
        print("Failed to fetch post: \(error)")
    }
}
```

## Custom Error Types

Creating specific error types helps you handle different failure scenarios appropriately:

```swift
enum NetworkError: Error {
    case invalidURL
    case invalidResponse
    case invalidStatusCode(Int)
    case decodingError(Error)
    case noData
    case timeout
    case noInternetConnection
}

extension NetworkError: LocalizedError {
    var errorDescription: String? {
        switch self {
        case .invalidURL:
            return "The URL is invalid"
        case .invalidResponse:
            return "Invalid response from server"
        case .invalidStatusCode(let code):
            return "Invalid status code: \(code)"
        case .decodingError(let error):
            return "Failed to decode: \(error.localizedDescription)"
        case .noData:
            return "No data received"
        case .timeout:
            return "Request timed out"
        case .noInternetConnection:
            return "No internet connection"
        }
    }
}
```

## Advanced Networking with URLRequest

For more control (headers, HTTP methods, body), use `URLRequest`:

```swift
struct CreatePostRequest: Codable {
    let title: String
    let body: String
    let userId: Int
}

func createPost(request: CreatePostRequest) async throws -> Post {
    guard let url = URL(string: "https://jsonplaceholder.typicode.com/posts") else {
        throw NetworkError.invalidURL
    }
    
    var urlRequest = URLRequest(url: url)
    urlRequest.httpMethod = "POST"
    urlRequest.setValue("application/json", forHTTPHeaderField: "Content-Type")
    urlRequest.setValue("Bearer your-token-here", forHTTPHeaderField: "Authorization")
    
    // Encode request body
    let encoder = JSONEncoder()
    urlRequest.httpBody = try encoder.encode(request)
    
    let (data, response) = try await URLSession.shared.data(for: urlRequest)
    
    guard let httpResponse = response as? HTTPURLResponse else {
        throw NetworkError.invalidResponse
    }
    
    guard (200...299).contains(httpResponse.statusCode) else {
        throw NetworkError.invalidStatusCode(httpResponse.statusCode)
    }
    
    let post = try JSONDecoder().decode(Post.self, from: data)
    return post
}
```

## Implementing Timeouts

By default, URLSession uses a generous timeout. You can customize this with a `URLSessionConfiguration`:

```swift
class NetworkService {
    private let session: URLSession
    
    init(timeoutInterval: TimeInterval = 30) {
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = timeoutInterval
        config.timeoutIntervalForResource = timeoutInterval * 2
        self.session = URLSession(configuration: config)
    }
    
    func fetchData(from url: URL) async throws -> Data {
        let (data, response) = try await session.data(from: url)
        
        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode) else {
            throw NetworkError.invalidResponse
        }
        
        return data
    }
}
```

### Using Swift's Task Timeout (iOS 16+)

For more granular timeout control, use Swift's `Task` with timeout:

```swift
func fetchWithTimeout<T>(timeout: TimeInterval, operation: @escaping () async throws -> T) async throws -> T {
    try await withThrowingTaskGroup(of: T.self) { group in
        // Start the actual operation
        group.addTask {
            try await operation()
        }
        
        // Start timeout task
        group.addTask {
            try await Task.sleep(nanoseconds: UInt64(timeout * 1_000_000_000))
            throw NetworkError.timeout
        }
        
        // Return first result (either success or timeout)
        let result = try await group.next()!
        group.cancelAll()
        return result
    }
}

// Usage
Task {
    do {
        let post = try await fetchWithTimeout(timeout: 5.0) {
            try await fetchPost(id: 1)
        }
        print(post)
    } catch NetworkError.timeout {
        print("Request timed out")
    } catch {
        print("Error: \(error)")
    }
}
```

## Handling Common Scenarios

### Checking Internet Connectivity

```swift
import Network

class NetworkMonitor {
    static let shared = NetworkMonitor()
    private let monitor = NWPathMonitor()
    private(set) var isConnected = false
    
    private init() {
        monitor.pathUpdateHandler = { [weak self] path in
            self?.isConnected = path.status == .satisfied
        }
        let queue = DispatchQueue(label: "NetworkMonitor")
        monitor.start(queue: queue)
    }
}

// Before making a request
guard NetworkMonitor.shared.isConnected else {
    throw NetworkError.noInternetConnection
}
```

### Retry Logic

```swift
func fetchWithRetry<T>(maxAttempts: Int = 3, delay: TimeInterval = 2.0, operation: () async throws -> T) async throws -> T {
    var lastError: Error?
    
    for attempt in 1...maxAttempts {
        do {
            return try await operation()
        } catch {
            lastError = error
            
            if attempt < maxAttempts {
                // Wait before retrying
                try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))
            }
        }
    }
    
    throw lastError ?? NetworkError.invalidResponse
}

// Usage
let post = try await fetchWithRetry {
    try await fetchPost(id: 1)
}
```

### Cancellation Support

Tasks can be cancelled, and URLSession respects this:

```swift
class PostViewModel: ObservableObject {
    @Published var post: Post?
    @Published var error: Error?
    private var fetchTask: Task<Void, Never>?
    
    func loadPost(id: Int) {
        // Cancel previous task if exists
        fetchTask?.cancel()
        
        fetchTask = Task {
            do {
                let post = try await fetchPost(id: id)
                
                // Check if cancelled before updating
                guard !Task.isCancelled else { return }
                
                self.post = post
            } catch {
                guard !Task.isCancelled else { return }
                self.error = error
            }
        }
    }
    
    func cancelLoad() {
        fetchTask?.cancel()
    }
}
```

## Handling Different Response Types

### Download Files

```swift
func downloadImage(from url: URL) async throws -> UIImage {
    let (localURL, response) = try await URLSession.shared.download(from: url)
    
    guard let httpResponse = response as? HTTPURLResponse,
          (200...299).contains(httpResponse.statusCode) else {
        throw NetworkError.invalidResponse
    }
    
    let data = try Data(contentsOf: localURL)
    
    guard let image = UIImage(data: data) else {
        throw NetworkError.decodingError(NSError(domain: "ImageError", code: 0))
    }
    
    return image
}
```

### Upload Files

```swift
func uploadImage(_ image: UIImage, to url: URL) async throws -> Bool {
    guard let imageData = image.jpegData(compressionQuality: 0.8) else {
        throw NetworkError.noData
    }
    
    var request = URLRequest(url: url)
    request.httpMethod = "POST"
    request.setValue("image/jpeg", forHTTPHeaderField: "Content-Type")
    
    let (_, response) = try await URLSession.shared.upload(for: request, from: imageData)
    
    guard let httpResponse = response as? HTTPURLResponse,
          (200...299).contains(httpResponse.statusCode) else {
        throw NetworkError.invalidResponse
    }
    
    return true
}
```

## Common Mistakes and Edge Cases

### Mistake 1: Not Checking Task Cancellation

```swift
// BAD: May update UI after cancellation
Task {
    let data = try await fetchData()
    self.updateUI(data) // Could crash if view is deallocated
}

// GOOD: Check cancellation
Task {
    let data = try await fetchData()
    guard !Task.isCancelled else { return }
    self.updateUI(data)
}
```

### Mistake 2: Ignoring HTTP Status Codes

```swift
// BAD: Assumes success if no error thrown
let (data, _) = try await URLSession.shared.data(from: url)
return try JSONDecoder().decode(User.self, from: data)

// GOOD: Validate status code
let (data, response) = try await URLSession.shared.data(from: url)
guard let httpResponse = response as? HTTPURLResponse,
      (200...299).contains(httpResponse.statusCode) else {
    throw NetworkError.invalidStatusCode((response as? HTTPURLResponse)?.statusCode ?? 0)
}
return try JSONDecoder().decode(User.self, from: data)
```

### Mistake 3: Not Handling Decoding Errors Properly

```swift
// GOOD: Wrap decoding in specific error
do {
    return try JSONDecoder().decode(User.self, from: data)
} catch {
    throw NetworkError.decodingError(error)
}
```

### Edge Case: Empty Response Bodies

```swift
func deletePost(id: Int) async throws {
    let url = URL(string: "https://api.example.com/posts/\(id)")!
    var request = URLRequest(url: url)
    request.httpMethod = "DELETE"
    
    let (data, response) = try await URLSession.shared.data(for: request)
    
    guard let httpResponse = response as? HTTPURLResponse,
          (200...299).contains(httpResponse.statusCode) else {
        throw NetworkError.invalidStatusCode((response as? HTTPURLResponse)?.statusCode ?? 0)
    }
    
    // DELETE may return empty body - don't try to decode if 204 No Content
    if httpResponse.statusCode != 204 && !data.isEmpty {
        // Process response if needed
    }
}
```

## Complete Example: Reusable Network Service

Here's a production-ready network service:

```swift
protocol NetworkServiceProtocol {
    func request<T: Decodable>(_ endpoint: Endpoint) async throws -> T
}

struct Endpoint {
    let path: String
    let method: HTTPMethod
    let headers: [String: String]?
    let body: Encodable?
    let queryItems: [URLQueryItem]?
    
    enum HTTPMethod: String {
        case get = "GET"
        case post = "POST"
        case put = "PUT"
        case delete = "DELETE"
    }
}

class NetworkService: NetworkServiceProtocol {
    private let session: URLSession
    private let baseURL: URL
    
    init(baseURL: URL, timeoutInterval: TimeInterval = 30) {
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = timeoutInterval
        self.session = URLSession(configuration: config)
        self.baseURL = baseURL
    }
    
    func request<T: Decodable>(_ endpoint: Endpoint) async throws -> T {
        let request = try buildRequest(from: endpoint)
        let (data, response) = try await session.data(for: request)
        
        try validateResponse(response, data: data)
        
        do {
            let decoder = JSONDecoder()
            decoder.keyDecodingStrategy = .convertFromSnakeCase
            return try decoder.decode(T.self, from: data)
        } catch {
            throw NetworkError.decodingError(error)
        }
    }
    
    private func buildRequest(from endpoint: Endpoint) throws -> URLRequest {
        var components = URLComponents(url: baseURL.appendingPathComponent(endpoint.path), resolvingAgainstBaseURL: true)
        components?.queryItems = endpoint.queryItems
        
        guard let url = components?.url else {
            throw NetworkError.invalidURL
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = endpoint.method.rawValue
        
        endpoint.headers?.forEach { key, value in
            request.setValue(value, forHTTPHeaderField: key)
        }
        
        if let body = endpoint.body {
            request.setValue("application/json", forHTTPHeaderField: "Content-Type")
            request.httpBody = try JSONEncoder().encode(body)
        }
        
        return request
    }
    
    private func validateResponse(_ response: URLResponse, data: Data) throws {
        guard let httpResponse = response as? HTTPURLResponse else {
            throw NetworkError.invalidResponse
        }
        
        guard (200...299).contains(httpResponse.statusCode) else {
            throw NetworkError.invalidStatusCode(httpResponse.statusCode)
        }
    }
}

// Usage
let service = NetworkService(baseURL: URL(string: "https://api.example.com")!)

let endpoint = Endpoint(
    path: "/posts/1",
    method: .get,
    headers: ["Authorization": "Bearer token"],
    body: nil,
    queryItems: nil
)

let post: Post = try await service.request(endpoint)
```

## Testing Async Network Code

Use `URLProtocol` to mock network responses:

```swift
class MockURLProtocol: URLProtocol {
    static var mockData: Data?
    static var mockResponse: HTTPURLResponse?
    static var mockError: Error?
    
    override class func canInit(with request: URLRequest) -> Bool {
        return true
    }

    override class func canonicalRequest(for request: URLRequest) -> URLRequest {
        return request
    }

    override func startLoading() {
        if let error = MockURLProtocol.mockError {
            client?.urlProtocol(self, didFailWithError: error)
            return
        }

        if let response = MockURLProtocol.mockResponse {
            client?.urlProtocol(self, didReceive: response, cacheStoragePolicy: .notAllowed)
        }

        if let data = MockURLProtocol.mockData {
            client?.urlProtocol(self, didLoad: data)
        }

        client?.urlProtocolDidFinishLoading(self)
    }

    override func stopLoading() { }
}

// Usage in tests
func testFetchPost() async throws {
    let config = URLSessionConfiguration.ephemeral
    config.protocolClasses = [MockURLProtocol.self]
    let session = URLSession(configuration: config)

    let mockPost = Post(id: 1, title: "Test", body: "Body")
    MockURLProtocol.mockData = try JSONEncoder().encode(mockPost)
    MockURLProtocol.mockResponse = HTTPURLResponse(
        url: URL(string: "https://example.com")!,
        statusCode: 200,
        httpVersion: nil,
        headerFields: nil
    )

    let (data, _) = try await session.data(from: URL(string: "https://example.com/posts/1")!)
    let post = try JSONDecoder().decode(Post.self, from: data)

    assert(post.title == "Test")
}
```

## Summary Table

| Concept | Syntax | Purpose |
|---------|--------|---------|
| **Async GET** | `try await URLSession.shared.data(from: url)` | Fetch data asynchronously |
| **Async POST** | `try await URLSession.shared.data(for: request)` | Send data asynchronously |
| **Custom errors** | `enum NetworkError: Error` | Typed error handling |
| **Timeout config** | `config.timeoutIntervalForRequest` | Set request timeout |
| **Task timeout** | `withThrowingTaskGroup` + `Task.sleep` | Granular timeout control |
| **Retry logic** | Loop with `Task.sleep` delay | Automatic retry on failure |
| **Cancellation** | `task.cancel()` + `Task.isCancelled` | Cancel in-flight requests |
| **Network monitor** | `NWPathMonitor` | Check connectivity |
| **Download** | `URLSession.shared.download(from:)` | Download files |
| **Upload** | `URLSession.shared.upload(for:from:)` | Upload data |
| **Mock testing** | `MockURLProtocol` | Test without network |

## Official Resources

- [Apple Documentation: URLSession](https://developer.apple.com/documentation/foundation/urlsession)
- [Apple Documentation: Concurrency](https://developer.apple.com/documentation/swift/concurrency)
- [Apple Documentation: NWPathMonitor](https://developer.apple.com/documentation/network/nwpathmonitor)
- [WWDC 2021: Use async/await with URLSession](https://developer.apple.com/videos/play/wwdc2021/10095/)